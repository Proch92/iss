/*
 * This is a textual representation a model expressed using the Qak language (metamodel)
 * that describes the structure, interaction, behaviour of the software system
 * according to the requirements
 */

System robotmind

Dispatch step	: step(DURATION)
Request step	: step(DURATION)
Reply stepdone	: stepdone(V)
Reply stepfail	: stepfail(DURATION, CAUSE)
Dispatch stop	: stop(X)
Dispatch cmd	: cmd(X)
Event obstacle	: obstacle(DISTANCE)

Context ctxMind			ip [ host= "192.168.1.92"	port= 8020 ]
Context ctxBasicRobot	ip [ host= "192.168.1.117"	port= 8030 ]

ExternalQActor robot context ctxBasicRobot 

QActor robotmind context ctxMind {
	["
	var StepTime = 500L 
	var Duration = 0 
	var WithResource = true
	var DoStepAnswer = false
	"]
	State s0 initial {
		println("robotmind | init")
	}
	Goto activateResource  if "WithResource" else idle
	
	State activateResource{
		run kotlincode.resServer.init(myself)
		run kotlincode.coapSupport.init("coap://localhost:5683")
		delay 1000 
		run kotlincode.resourceObserver.init("coap://localhost:5683","robot/pos")
	}
	Goto idle

	State idle {
		println("robotmind | idle")
	}
	Transition tWork
		whenMsg step		-> doStepNoAnswer
		whenRequest step	-> doStepWithAnswer
		whenMsg cmd			-> sHandleCmd
		whenMsg stop		-> sHandleStopUnexpected
	
	State sHandleStopUnexpected {
		println("robotmind | sHandleStopUnexpected - not expecting stop command outside of step context")
	}
	Goto idle

	State sHandleCmd {
		onMsg( cmd : cmd(X) ){ 
			["var Move = payloadArg(0)"]
			forward robot -m cmd : cmd( $Move )
			if "( WithResource )" {
				run kotlincode.coapSupport.updateResource(myself, "robot/pos", "u$Move")
			}
		}
	}
	Goto idle

	// ----------------- STEP ------------------

	State doStepNoAnswer {    
    	onMsg(step : step(T)){
    		["
				StepTime = payloadArg(0).toLong();
				DoStepAnswer = false
			"]
    	}
    } Goto doStep

    State doStepWithAnswer {  
    	onMsg(step : step(T)){
    		["
				StepTime = payloadArg(0).toLong();
				DoStepAnswer = true
			"]
    	}
    } Goto doStep
     
	State doStep{
 		println("robotmind | doStep StepTime = $StepTime")
 		["startTimer()"]
		forward robot -m cmd : cmd(w)
 	}
	Transition t0
		whenTimeVar StepTime  -> endStep
		whenMsg stop          -> stepStop
		whenEvent obstacle    -> stepFail
 	
	State endStep{
		forward robot -m cmd : cmd( h )
		println("robotmind | step DONE")
		if "WithResource" { run kotlincode.coapSupport.updateResource(myself, "robot/pos", "up") }
		if "DoStepAnswer" { replyTo step with stepdone : stepdone(ok) }
  	}
	Goto idle

	State stepStop{
		["Duration = getDuration()"]
		forward robot -m cmd : cmd( h )
		println("robotmind | stepStop Duration=$Duration")
		if "DoStepAnswer" { replyTo step with stepfail : stepfail($Duration, stopped) }
 	}
	Goto idle  	 

	State stepFail{
		["Duration = getDuration()"]
		println("robotmind | stepFail Duration=$Duration ")
		if "DoStepAnswer" { replyTo step with stepfail : stepfail($Duration, obstacle) }
  	}
	Goto revertStep
	
	State revertStep {
		println("robotmind | revertStep")
		forward robot -m cmd : cmd(s)
	}
	Transition trevert
		whenTimeVar Duration -> stopRevert
	
	State stopRevert {
		println("robotmind | stopRevert")
		forward robot -m cmd : cmd(h)
	}
	Goto idle
}

QActor detector context ctxMind {
	["
	var MaxTrash = 2
	var CurrentTrash = 0
	"]
	State init initial {
		println("detector | init")
		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.moveUtils.showCurrentRobotState()
		run mystuff.DFSUtil.movedOn(0, 0)
	}
	Goto wander
	
	State checkBin {
		println("detector | think")
	}
	Goto discharge if "(MaxTrash == CurrentTrash)" else wander
	
	State wander {
		println("detector | searchNext")
		["var (Next_x, Next_y) = mystuff.DFSUtil.next()"]
		run itunibo.planner.plannerUtil.setGoal("$Next_x","$Next_y")
		run itunibo.planner.plannerUtil.doPlan() 
		run itunibo.planner.plannerUtil.executeMoves()
		run itunibo.planner.plannerUtil.showMap()
	}
	Goto checkBin
	
}
