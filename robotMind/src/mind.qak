/*
 * This is a textual representation a model expressed using the Qak language (metamodel)
 * that describes the structure, interaction, behaviour of the software system
 * according to the requirements
 */

System robotmind

Dispatch step	: step(DURATION)
Request step	: step(DURATION)
Reply stepdone	: stepdone(V)
Reply stepfail	: stepfail(DURATION, CAUSE)
Event stepdone	: stepdone(V)
Event stepfail	: stepfail(DURATION, CAUSE)
Dispatch stop	: stop(X)
Dispatch cmd	: cmd(X)
Event obstacle	: obstacle(DISTANCE)

Dispatch itsPlastic : itsPlastic(X)
Dispatch itsObstacle : itsObstacle(X)

Context ctxMind			ip [ host= "192.168.1.92"	port= 8020 ]
Context ctxBasicRobot	ip [ host= "192.168.1.117"	port= 8030 ]

ExternalQActor robot context ctxBasicRobot 

QActor robotmind context ctxMind {
	["
	var StepTime = 500L 
	var Duration = 0L
	var WithResource = true
	var DoStepAnswer = false
	"]
	State s0 initial {
		println("robotmind | init")
	}
	Goto activateResource  if "WithResource" else idle
	
	State activateResource{
		run kotlincode.resServer.init(myself)
		run kotlincode.coapSupport.init("coap://localhost:5683")
		delay 1000 
		run kotlincode.resourceObserver.init("coap://localhost:5683","robot/pos")
	}
	Goto idle

	State idle {
		println("robotmind | idle")
		["myai.RobotState.print()"]
	}
	Transition tWork
		whenMsg step		-> doStepNoAnswer
		whenRequest step	-> doStepWithAnswer
		whenMsg cmd			-> sHandleCmd
		whenMsg stop		-> sHandleStopUnexpected
	
	State sHandleStopUnexpected {
		println("robotmind | sHandleStopUnexpected - not expecting stop command outside of step context")
	}
	Goto idle

	State sHandleCmd {
		onMsg( cmd : cmd(X) ){ 
			["
			var Move = payloadArg(0)
			myai.RobotState.update(Move)
			"]
			forward robot -m cmd : cmd( $Move )
			if "( WithResource )" {
				run kotlincode.coapSupport.updateResource(myself, "robot/pos", "u$Move")
			}
		}
	}
	Goto idle

	// ----------------- STEP ------------------

	State doStepNoAnswer {    
    	onMsg(step : step(T)){
    		["
				StepTime = payloadArg(0).toLong();
				DoStepAnswer = false
			"]
    	}
    } Goto doStep

    State doStepWithAnswer {  
    	onMsg(step : step(T)){
    		["
				StepTime = payloadArg(0).toLong();
				DoStepAnswer = true
			"]
    	}
    } Goto doStep
     
	State doStep{
 		println("robotmind | doStep StepTime = $StepTime")
 		["startTimer()"]
		forward robot -m cmd : cmd(w)
 	}
	Transition t0
		whenTimeVar StepTime  -> endStep
		whenMsg stop          -> stepStop
		whenEvent obstacle    -> stepFail
 	
	State endStep{
		["myai.RobotState.update(\"step\")"]
		forward robot -m cmd : cmd( h )
		println("robotmind | step DONE")
		if "WithResource" { run kotlincode.coapSupport.updateResource(myself, "robot/pos", "up") }
		if "DoStepAnswer" { replyTo step with stepdone : stepdone(ok) }
		emit stepdone : stepdone(ok)
  	}
	Goto idle

	State stepStop{
		["Duration = getDuration().toLong()"]
		forward robot -m cmd : cmd( h )
		println("robotmind | stepStop Duration=$Duration")
		if "DoStepAnswer" { replyTo step with stepfail : stepfail($Duration, stopped) }
		emit stepfail : stepfail($Duration, stopped)
 	}
	Goto revertStep  	 

	State stepFail{
		["Duration = getDuration().toLong()"]
		println("robotmind | stepFail Duration=$Duration ")
		if "DoStepAnswer" { replyTo step with stepfail : stepfail($Duration, obstacle) }
		emit stepfail : stepfail($Duration, obstacle)
  	}
	Goto revertStep
	
	State revertStep {
		println("robotmind | revertStep")
		forward robot -m cmd : cmd(s)
	}
	Transition trevert
		whenTimeVar Duration -> stopRevert
	
	State stopRevert {
		println("robotmind | stopRevert")
		forward robot -m cmd : cmd(h)
	}
	Goto idle
}

QActor detector context ctxMind {
	["
	var MaxTrash = 2
	var CurrentTrash = 0
	val room = myai.Room()
	val dfs = myai.DFSUtil(room)
	val planner = myai.Planner(room)
	val StepDuration = 500
	var Goal : Pair<Int, Int> = Pair(0, 0)
	"]
	State init initial {
		println("detector | init")
		["
		dfs.movedOn(Pair(0, 0))
		room.print()
		"]
	}
	Goto explore
	
	State discharge {
		println("detector | discharge")
		["
		Goal = Pair(0, 0)
		planner.new_plan(Goal)
		planner.executePlan(myself)
		"]
	}
	Goto waitPlanCompletion
	
	State explore {
		println("detector | searchNext")
		["
		Goal = dfs.next()
		planner.new_plan(Goal)
		planner.executePlan(myself)
		"]
	}
	Goto waitPlanCompletion
	
	State waitPlanCompletion {
		println("detector | waitPlanCompletion")
	}
	Transition twait
		whenEvent stepdone -> checkGoal
		whenEvent stepfail -> askObstacle
	
	State checkGoal {
		println("detector | checkGoal")
		["
		val cur_x = myai.RobotState.x
		val cur_y = myai.RobotState.y
		if (cur_x == 0 && cur_y == 0) {
			println(\"emptying the trash\")
			myai.PlasticBox.dump(CurrentTrash)
			CurrentTrash = 0
		}
		room.put(cur_x, cur_y, myai.Type.FREE)
		"]
	}
	Goto explore if "(Pair(myai.RobotState.x, myai.RobotState.y) == Goal)" else waitPlanCompletion
	
	State askObstacle {
		println("detector | askObstalce")
		// ask if plastic bottle or obstacle
	}
	Transition task
		whenMsg itsPlastic -> plasticFound
		whenMsg itsObstacle -> obstacleFound
	
	State plasticFound {
		println("detector | plasticFound")
		["CurrentTrash += 1"]
	}
	Goto discharge if "(MaxTrash == CurrentTrash)" else explore
	
	State obstacleFound {
		println("detector | obstacleFound")
		["
		val (gx, gy) = Goal
		room.put(gx, gy, myai.Type.OBSTACLE)
		"]
	}
	Goto explore
}
