/* Generated by AN DISI Unibo */ 
package it.unibo.robotmind

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Robotmind ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
			var StepTime = 500L 
			var Duration = 0L
			var WithResource = true
			var DoStepAnswer = false
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("robotmind | init")
					}
					 transition( edgeName="goto",targetState="activateResource", cond=doswitchGuarded({WithResource}) )
					transition( edgeName="goto",targetState="idle", cond=doswitchGuarded({! WithResource}) )
				}	 
				state("activateResource") { //this:State
					action { //it:State
						kotlincode.resServer.init(myself)
						kotlincode.coapSupport.init( "coap://localhost:5683"  )
						delay(1000) 
						kotlincode.resourceObserver.init( "coap://localhost:5683", "robot/pos"  )
					}
					 transition( edgeName="goto",targetState="idle", cond=doswitch() )
				}	 
				state("idle") { //this:State
					action { //it:State
						println("robotmind | idle")
						myai.RobotState.print()
					}
					 transition(edgeName="tWork0",targetState="doStepNoAnswer",cond=whenDispatch("step"))
					transition(edgeName="tWork1",targetState="doStepWithAnswer",cond=whenRequest("step"))
					transition(edgeName="tWork2",targetState="sHandleCmd",cond=whenDispatch("cmd"))
					transition(edgeName="tWork3",targetState="sHandleStopUnexpected",cond=whenDispatch("stop"))
				}	 
				state("sHandleStopUnexpected") { //this:State
					action { //it:State
						println("robotmind | sHandleStopUnexpected - not expecting stop command outside of step context")
					}
					 transition( edgeName="goto",targetState="idle", cond=doswitch() )
				}	 
				state("sHandleCmd") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("cmd(X)"), Term.createTerm("cmd(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
											var Move = payloadArg(0)
											println("robotmind | received $Move")
											myai.RobotState.update(Move)
								forward("cmd", "cmd($Move)" ,"robot" ) 
								if(( WithResource )){ kotlincode.coapSupport.updateResource(myself ,"robot/pos", "u$Move" )
								 }
						}
					}
					 transition( edgeName="goto",targetState="idle", cond=doswitch() )
				}	 
				state("doStepNoAnswer") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("step(DURATION)"), Term.createTerm("step(T)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
												StepTime = payloadArg(0).toLong();
												DoStepAnswer = false
						}
					}
					 transition( edgeName="goto",targetState="doStep", cond=doswitch() )
				}	 
				state("doStepWithAnswer") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("step(DURATION)"), Term.createTerm("step(T)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
												StepTime = payloadArg(0).toLong();
												DoStepAnswer = true
						}
					}
					 transition( edgeName="goto",targetState="doStep", cond=doswitch() )
				}	 
				state("doStep") { //this:State
					action { //it:State
						println("robotmind | doStep StepTime = $StepTime")
						startTimer()
						forward("cmd", "cmd(w)" ,"robot" ) 
						stateTimer = TimerActor("timer_doStep", 
							scope, context!!, "local_tout_robotmind_doStep", StepTime )
					}
					 transition(edgeName="t04",targetState="endStep",cond=whenTimeout("local_tout_robotmind_doStep"))   
					transition(edgeName="t05",targetState="stepStop",cond=whenDispatch("stop"))
					transition(edgeName="t06",targetState="stepFail",cond=whenEvent("obstacle"))
				}	 
				state("endStep") { //this:State
					action { //it:State
						myai.RobotState.update("step")
						forward("cmd", "cmd(h)" ,"robot" ) 
						println("robotmind | step DONE")
						if(WithResource){ kotlincode.coapSupport.updateResource(myself ,"robot/pos", "up" )
						 }
						if(DoStepAnswer){ answer("step", "stepdone", "stepdone(ok)"   )  
						 }
						emit("stepdone", "stepdone(ok)" ) 
					}
					 transition( edgeName="goto",targetState="idle", cond=doswitch() )
				}	 
				state("stepStop") { //this:State
					action { //it:State
						Duration = getDuration().toLong()
						forward("cmd", "cmd(h)" ,"robot" ) 
						println("robotmind | stepStop Duration=$Duration")
						if(DoStepAnswer){ answer("step", "stepfail", "stepfail($Duration,stopped)"   )  
						 }
						emit("stepfail", "stepfail($Duration,stopped)" ) 
					}
					 transition( edgeName="goto",targetState="revertStep", cond=doswitch() )
				}	 
				state("stepFail") { //this:State
					action { //it:State
						Duration = getDuration().toLong()
						println("robotmind | stepFail Duration=$Duration ")
						if(DoStepAnswer){ answer("step", "stepfail", "stepfail($Duration,obstacle)"   )  
						 }
						emit("stepfail", "stepfail($Duration,obstacle)" ) 
					}
					 transition( edgeName="goto",targetState="revertStep", cond=doswitch() )
				}	 
				state("revertStep") { //this:State
					action { //it:State
						println("robotmind | revertStep")
						forward("cmd", "cmd(s)" ,"robot" ) 
						stateTimer = TimerActor("timer_revertStep", 
							scope, context!!, "local_tout_robotmind_revertStep", Duration )
					}
					 transition(edgeName="trevert7",targetState="stopRevert",cond=whenTimeout("local_tout_robotmind_revertStep"))   
				}	 
				state("stopRevert") { //this:State
					action { //it:State
						println("robotmind | stopRevert")
						forward("cmd", "cmd(h)" ,"robot" ) 
					}
					 transition( edgeName="goto",targetState="idle", cond=doswitch() )
				}	 
			}
		}
}
