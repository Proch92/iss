/* Generated by AN DISI Unibo */ 
package it.unibo.detector

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Detector ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "init"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
			var MaxTrash = 2
			var CurrentTrash = 0
			val room = myai.Room()
			val dfs = myai.DFSUtil(room)
			val planner = myai.Planner(room)
			val StepDuration = 500
			var Goal : Pair<Int, Int> = Pair(0, 0)
			val Suspended = false
		return { //this:ActionBasciFsm
				state("init") { //this:State
					action { //it:State
						println("detector | init")
						
								dfs.movedOn(Pair(0, 0))
								room.print()
					}
					 transition( edgeName="goto",targetState="idle", cond=doswitch() )
				}	 
				state("idle") { //this:State
					action { //it:State
						println("detector | idle")
					}
					 transition(edgeName="t08",targetState="explore",cond=whenDispatch("explore"))
				}	 
				state("sleep") { //this:State
					action { //it:State
						println("detector | sleep")
					}
					 transition(edgeName="tsleep9",targetState="idle",cond=whenDispatch("wakeup"))
				}	 
				state("discharge") { //this:State
					action { //it:State
						println("detector | discharge")
						
								Goal = Pair(0, 0)
								planner.new_plan(Goal)
								planner.executePlan(myself)
					}
					 transition( edgeName="goto",targetState="waitPlanCompletion", cond=doswitch() )
				}	 
				state("ssuspend") { //this:State
					action { //it:State
						println("detector | ssuspend")
						Suspended = true
					}
					 transition( edgeName="goto",targetState="discharge", cond=doswitch() )
				}	 
				state("explore") { //this:State
					action { //it:State
						println("detector | explore")
						
								Suspended = false
								room.print()
								Goal = dfs.next()
								println(Goal)
								planner.new_plan(Goal)
								planner.executePlan(myself)
					}
					 transition( edgeName="goto",targetState="waitPlanCompletion", cond=doswitch() )
				}	 
				state("waitPlanCompletion") { //this:State
					action { //it:State
						println("detector | waitPlanCompletion")
					}
					 transition(edgeName="twait10",targetState="checkGoal",cond=whenEvent("stepdone"))
					transition(edgeName="twait11",targetState="askObstacle",cond=whenEvent("stepfail"))
					transition(edgeName="twait12",targetState="ssuspend",cond=whenDispatch("suspend"))
				}	 
				state("checkGoal") { //this:State
					action { //it:State
						println("detector | checkGoal")
						
								val cur_x = myai.RobotState.x
								val cur_y = myai.RobotState.y
								if (cur_x == 0 && cur_y == 0) {
									println("emptying the trash")
									myai.PlasticBox.dump(CurrentTrash)
									CurrentTrash = 0
								}
								dfs.movedOn(Pair(cur_x, cur_y))
					}
					 transition( edgeName="goto",targetState="goalAchieved", cond=doswitchGuarded({(Pair(myai.RobotState.x, myai.RobotState.y) == Goal)}) )
					transition( edgeName="goto",targetState="waitPlanCompletion", cond=doswitchGuarded({! (Pair(myai.RobotState.x, myai.RobotState.y) == Goal)}) )
				}	 
				state("goalAchieved") { //this:State
					action { //it:State
						println("detector | goalAchieved")
					}
					 transition( edgeName="goto",targetState="explore", cond=doswitchGuarded({(Suspended == false)}) )
					transition( edgeName="goto",targetState="sleep", cond=doswitchGuarded({! (Suspended == false)}) )
				}	 
				state("askObstacle") { //this:State
					action { //it:State
						println("detector | askObstalce")
					}
					 transition(edgeName="task13",targetState="plasticFound",cond=whenEvent("itsPlastic"))
					transition(edgeName="task14",targetState="obstacleFound",cond=whenEvent("itsObstacle"))
					transition(edgeName="task15",targetState="ssuspend",cond=whenDispatch("suspend"))
				}	 
				state("plasticFound") { //this:State
					action { //it:State
						println("detector | plasticFound")
						CurrentTrash += 1
					}
					 transition( edgeName="goto",targetState="discharge", cond=doswitchGuarded({(MaxTrash == CurrentTrash)}) )
					transition( edgeName="goto",targetState="explore", cond=doswitchGuarded({! (MaxTrash == CurrentTrash)}) )
				}	 
				state("obstacleFound") { //this:State
					action { //it:State
						println("detector | obstacleFound")
						
								val (gx, gy) = Goal
								room.put(gx, gy, myai.Type.OBSTACLE)
					}
					 transition( edgeName="goto",targetState="explore", cond=doswitch() )
				}	 
			}
		}
}
